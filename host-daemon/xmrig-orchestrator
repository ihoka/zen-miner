#!/usr/bin/env ruby
# frozen_string_literal: true

# XMRig Orchestrator Daemon
# Polls Rails database for commands and manages XMRig systemd service

require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "sqlite3", "~> 2.4"
end

require "json"
require "net/http"
require "socket"
require "logger"
require "time"
require "open3"

class XmrigOrchestrator
  POLL_INTERVAL = 10 # seconds
  DB_PATH = ENV.fetch("XMRIG_DB_PATH", "/mnt/rails-storage/production.sqlite3")
  LOG_PATH = ENV.fetch("XMRIG_LOG_PATH", "/var/log/xmrig/orchestrator.log")
  XMRIG_API_URL = ENV.fetch("XMRIG_API_URL", "http://127.0.0.1:8080/2/summary")

  # Allowed columns for update_process_status (SQL injection protection)
  ALLOWED_PROCESS_COLUMNS = %w[
    status pid hostname worker_id started_at stopped_at error_count
    last_error last_health_check_at restart_count hashrate
    accepted_shares rejected_shares health_data
  ].freeze

  def initialize
    @hostname = Socket.gethostname
    @logger = Logger.new(LOG_PATH, 7, "daily") # 7 day retention, daily rotation
    @logger.level = Logger::INFO
    @db = SQLite3::Database.new(DB_PATH)
    @db.results_as_hash = true

    # Enable WAL mode for better concurrency with Rails app
    @db.execute("PRAGMA journal_mode=WAL")
    @db.execute("PRAGMA synchronous=NORMAL")
    @db.execute("PRAGMA busy_timeout=5000")
  end

  def run
    @logger.info "XMRig Orchestrator starting on #{@hostname}"
    @logger.info "Database: #{DB_PATH}"
    @logger.info "XMRig API: #{XMRIG_API_URL}"

    loop do
      begin
        process_pending_commands
        update_health_status
        sleep POLL_INTERVAL
      rescue => e
        @logger.error "Error in main loop: #{e.message}"
        @logger.error e.backtrace.join("\n")
        sleep 30 # Back off on errors
      end
    end
  end

  private

  def process_pending_commands
    # Fetch and mark commands as processing within a transaction to prevent race conditions
    commands = @db.transaction do
      pending = @db.execute(
        "SELECT * FROM xmrig_commands WHERE hostname = ? AND status = 'pending' ORDER BY created_at ASC",
        [@hostname]
      )

      # Mark all pending commands as processing atomically
      pending.each do |cmd|
        @db.execute(
          "UPDATE xmrig_commands SET status = 'processing', processed_at = ? WHERE id = ?",
          [Time.now.utc.iso8601, cmd["id"]]
        )
      end

      pending
    end

    commands.each do |cmd|
      process_command(cmd)
    end
  end

  def process_command(cmd)
    @logger.info "Processing command: #{cmd['action']} (ID: #{cmd['id']})"

    # Command is already marked as processing by process_pending_commands transaction
    result = case cmd["action"]
    when "start"
      systemctl("start")
    when "stop"
      systemctl("stop")
    when "restart"
      systemctl("restart")
    else
      "Unknown action: #{cmd['action']}"
    end

    if $?.success?
      @db.execute(
        "UPDATE xmrig_commands SET status = 'completed', result = ? WHERE id = ?",
        [result, cmd["id"]]
      )
      @logger.info "Command completed: #{cmd['action']}"
    else
      @db.execute(
        "UPDATE xmrig_commands SET status = 'failed', error_message = ? WHERE id = ?",
        [result, cmd["id"]]
      )
      @logger.error "Command failed: #{cmd['action']} - #{result}"
    end
  rescue => e
    @db.execute(
      "UPDATE xmrig_commands SET status = 'failed', error_message = ? WHERE id = ?",
      [e.message, cmd["id"]]
    )
    @logger.error "Command error: #{e.message}"
  end

  def systemctl(action)
    # Use array form to avoid shell injection (subprocess will exec directly)
    # Using sudo with NOPASSWD configuration for specific systemctl commands
    stdout, stderr, status = Open3.capture3('sudo', 'systemctl', action, 'xmrig')
    output = stdout + stderr

    # Set $? for compatibility with existing code that checks $?.success?
    # This is a workaround since Open3 doesn't set $? directly
    unless status.success?
      # Signal failure by creating a failed Process::Status
      system('false')
    end

    output
  end

  def update_health_status
    health = fetch_xmrig_health

    if health
      update_process_status(
        status: "running",
        pid: health["worker_id"],
        hashrate: health.dig("hashrate", "total", 0),
        accepted_shares: health.dig("results", "shares_good"),
        rejected_shares: health.dig("results", "shares_bad"),
        health_data: health.to_json
      )

      # Check for errors
      if health.dig("hashrate", "total", 0) == 0
        @logger.warn "Zero hashrate detected"
        check_and_restart_if_needed("zero_hashrate")
      end
    else
      # XMRig not responding
      status_output, _stderr, _status = Open3.capture3('sudo', 'systemctl', 'is-active', 'xmrig')
      status_output = status_output.strip

      if status_output == "active"
        update_process_status(status: "unhealthy")
        check_and_restart_if_needed("api_not_responding")
      else
        update_process_status(status: "stopped")
      end
    end
  rescue => e
    @logger.error "Health check error: #{e.message}"
  end

  def fetch_xmrig_health
    uri = URI(XMRIG_API_URL)

    # Set timeouts to prevent hanging on unresponsive API
    response = Net::HTTP.start(uri.host, uri.port,
                                open_timeout: 5,
                                read_timeout: 5,
                                write_timeout: 5) do |http|
      http.get(uri.path.empty? ? '/' : uri.path)
    end

    return nil unless response.is_a?(Net::HTTPSuccess)

    JSON.parse(response.body)
  rescue Errno::ECONNREFUSED, SocketError, JSON::ParserError, Net::OpenTimeout, Net::ReadTimeout => e
    @logger.debug "XMRig API not accessible: #{e.class}"
    nil
  end

  def update_process_status(attrs)
    attrs[:hostname] = @hostname
    attrs[:worker_id] ||= "#{@hostname}-production"
    attrs[:last_health_check_at] = Time.now.utc.iso8601

    # Filter to only allowed columns (SQL injection protection)
    safe_attrs = attrs.select { |k, _| ALLOWED_PROCESS_COLUMNS.include?(k.to_s) }

    if safe_attrs.empty?
      @logger.warn "No valid columns to update in update_process_status"
      return
    end

    existing = @db.execute(
      "SELECT id FROM xmrig_processes WHERE hostname = ?",
      [@hostname]
    ).first

    if existing
      set_clause = safe_attrs.map { |k, _| "#{k} = ?" }.join(", ")
      values = safe_attrs.values + [Time.now.utc.iso8601, existing["id"]]

      @db.execute(
        "UPDATE xmrig_processes SET #{set_clause}, updated_at = ? WHERE id = ?",
        values
      )
    else
      columns = safe_attrs.keys.join(", ")
      placeholders = (["?"] * safe_attrs.size).join(", ")

      @db.execute(
        "INSERT INTO xmrig_processes (#{columns}, created_at, updated_at) VALUES (#{placeholders}, ?, ?)",
        safe_attrs.values + [Time.now.utc.iso8601, Time.now.utc.iso8601]
      )
    end
  end

  def check_and_restart_if_needed(reason)
    # Immediate restart on any error (dedicated mining machines)
    @logger.warn "Error detected, issuing immediate restart: #{reason}"

    @db.execute(
      "INSERT INTO xmrig_commands (hostname, action, reason, status, created_at, updated_at) VALUES (?, 'restart', ?, 'pending', ?, ?)",
      [@hostname, reason, Time.now.utc.iso8601, Time.now.utc.iso8601]
    )

    @db.execute(
      "UPDATE xmrig_processes SET restart_count = restart_count + 1, error_count = error_count + 1, last_error = ? WHERE hostname = ?",
      [reason, @hostname]
    )
  end
end

# Signal handling for graceful shutdown
trap("INT") do
  puts "\nShutting down XMRig Orchestrator..."
  exit 0
end

trap("TERM") do
  puts "\nShutting down XMRig Orchestrator..."
  exit 0
end

# Run daemon
XmrigOrchestrator.new.run
